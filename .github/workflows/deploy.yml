name: Deploy

on:
  workflow_dispatch:  # Manual deployment
  push:
    branches:
      - main  # Automatic deployment on merge to main

jobs:
  build-and-push:
    name: Build and Push to GHCR
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Server
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Install 1Password CLI
        uses: 1password/install-cli-action@v2

      - name: Generate .env file from 1Password
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
        run: |
          # Use op inject to generate .env from .env.tpl
          op inject -i .env.tpl -o .env

          # Construct DATABASE_URL from individual variables (op inject doesn't expand refs in strings)
          # Use grep to safely extract values without shell interpretation issues
          PG_USER=$(grep '^POSTGRES_USER=' .env | cut -d'=' -f2-)
          PG_PASS=$(grep '^POSTGRES_PASSWORD=' .env | cut -d'=' -f2-)
          PG_DB=$(grep '^POSTGRES_DB=' .env | cut -d'=' -f2-)

          # URL-encode the password to handle special characters (@, #, /, etc.)
          PG_PASS_ENCODED=$(printf '%s' "$PG_PASS" | jq -sRr @uri)
          # sslmode=disable is required because PostgreSQL container doesn't have SSL enabled
          echo "DATABASE_URL=postgresql://${PG_USER}:${PG_PASS_ENCODED}@postgres:5432/${PG_DB}?sslmode=disable" >> .env

          chmod 600 .env
          echo "✅ Generated .env file with secrets from 1Password"

      - name: Get server IP from 1Password
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
        run: |
          HETZNER_SERVER_IP=$(op read "op://Dev/HETZNER_SERVER_IP/credential")
          echo "HETZNER_SERVER_IP=$HETZNER_SERVER_IP" >> $GITHUB_ENV
          echo "✅ Loaded server IP from 1Password"

      - name: Get SSH key from 1Password
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
        run: |
          mkdir -p ~/.ssh
          # Extract SSH key in OpenSSH format using ssh-format query parameter
          op read "op://Dev/HETZNER_SSH_KEY/private key?ssh-format=openssh" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          echo "✅ Loaded SSH key from 1Password"

      - name: Copy deployment files to server
        run: |
          # Add server to known hosts
          ssh-keyscan -H "$HETZNER_SERVER_IP" >> ~/.ssh/known_hosts

          # Create directory structure
          ssh -i ~/.ssh/deploy_key root@"$HETZNER_SERVER_IP" "mkdir -p /opt/aiskualerts/db"

          # Copy files
          scp -i ~/.ssh/deploy_key .env root@"$HETZNER_SERVER_IP":/opt/aiskualerts/
          scp -i ~/.ssh/deploy_key docker-compose.yml root@"$HETZNER_SERVER_IP":/opt/aiskualerts/
          scp -i ~/.ssh/deploy_key nginx.conf root@"$HETZNER_SERVER_IP":/opt/aiskualerts/
          scp -i ~/.ssh/deploy_key -r db/migrations root@"$HETZNER_SERVER_IP":/opt/aiskualerts/db/
          scp -i ~/.ssh/deploy_key db/schema.sql root@"$HETZNER_SERVER_IP":/opt/aiskualerts/db/

          # Set permissions
          ssh -i ~/.ssh/deploy_key root@"$HETZNER_SERVER_IP" "chmod 600 /opt/aiskualerts/.env"

          echo "✅ Files copied to server"

      - name: Deploy on server
        run: |
          ssh -i ~/.ssh/deploy_key root@"$HETZNER_SERVER_IP" << ENDSSH
            set -euo pipefail
            cd /opt/aiskualerts

            # Login to GHCR to pull private image
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Force pull the specific SHA-tagged image to bypass cache
            docker pull ghcr.io/${{ github.repository }}:${{ github.sha }}

            # Tag it as latest for docker-compose
            docker tag ghcr.io/${{ github.repository }}:${{ github.sha }} ghcr.io/${{ github.repository }}:latest

            # Pull dbmate image for migrations
            docker pull ghcr.io/amacneil/dbmate:2.22

            # Stop and remove old containers
            docker compose down

            # Start database and wait for it to be healthy
            echo "Starting database..."
            docker compose up -d postgres

            # Wait for postgres to be healthy
            echo "Waiting for PostgreSQL to be ready..."
            for i in {1..30}; do
              if docker compose exec -T postgres pg_isready -U aiskualerts > /dev/null 2>&1; then
                echo "✅ PostgreSQL is ready"
                break
              fi
              echo "Waiting for PostgreSQL... (\$i/30)"
              sleep 2
            done

            # Start all services
            # Docker Compose handles the dependency order:
            # 1. postgres starts and becomes healthy
            # 2. migrations runs and completes (service_completed_successfully)
            # 3. app starts only after migrations succeed
            echo "Starting all services..."
            docker compose up -d

            # Wait for app to be healthy (migrations run automatically as dependency)
            echo "Waiting for application to start..."
            for i in {1..60}; do
              if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                echo "✅ Application is healthy!"
                break
              fi
              # Check if migrations failed
              if docker compose ps migrations 2>/dev/null | grep -q "Exit"; then
                EXIT_CODE=$(docker compose ps migrations --format json 2>/dev/null | jq -r '.[0].ExitCode // empty')
                if [ "$EXIT_CODE" != "0" ] && [ -n "$EXIT_CODE" ]; then
                  echo "❌ Migrations failed with exit code $EXIT_CODE"
                  docker compose logs migrations
                  docker compose down
                  exit 1
                fi
              fi
              echo "Waiting... (\$i/60)"
              sleep 2
            done

            # Clean up old images
            docker image prune -f

            echo "✅ Deployment complete"
          ENDSSH

      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/deploy_key root@"$HETZNER_SERVER_IP" << 'ENDSSH'
            set -euo pipefail
            cd /opt/aiskualerts

            echo "Waiting for application to be healthy..."
            for i in {1..30}; do
              if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                echo "✅ Application is healthy!"
                docker compose ps
                exit 0
              fi
              echo "Waiting... ($i/30)"
              sleep 2
            done

            echo "❌ Application failed health check"
            docker compose logs --tail=50
            exit 1
          ENDSSH

      - name: Cleanup sensitive files
        if: always()
        run: |
          rm -f .env
          rm -f ~/.ssh/deploy_key
          echo "✅ Cleaned up sensitive files"

      - name: Deployment summary
        if: success()
        run: |
          echo "✅ Deployment successful!"
          echo "Server: $HETZNER_SERVER_IP"
          echo "Image: ghcr.io/${{ github.repository }}:${{ github.sha }}"
          echo "Branch: ${GITHUB_REF_NAME}"
          echo "Commit: ${GITHUB_SHA::8}"
